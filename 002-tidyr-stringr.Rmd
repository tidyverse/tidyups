---
output: github_document
---

# Tidyup 2: tidyr \<-> stringr alignment

**Champion**: Hadley Wickham  
**Co-champion**: Mine Ã‡etinkaya-Rundel  
**Status**: Draft

## Abstract

tidyr provides a handful functions like `separate()` and `extract()` that perform string manipulation.
Unfortunately, these functions are only weakly connected to their stringr equivalents, making them harder to learn and remember.
This tidyup proposes a new cohesive family of string manipulation functions to tackle common problems that arise during data tidying.
The existing functions will remain so existing code is unaffected, but will be superseded to steer folks towards a more consistent API.

```{r setup}
library(tidyr)
library(stringr)
```

## Motivation

stringr and tidyr provide surprisingly different interfaces for string manipulation.
This means that common tasks require integrating two distinct syntaxes and learning more about stringr doesn't improve your use of tidyr.

The root cause of the problem is that stringr was designed before I understood the importance of data frames, so many stringr functions return matrices (or lists of matrices), which makes them hard to use with other tidyverse packages.
No stringr function returns a data frame, which is particularly painful given that `summarise()` and `mutate()` can now use data frame results to add multiple columns.

To overcome this weakness, tidyr provides a few functions that work directly with data frames.
These take a data frame and column specification, and return a modified data frame, typically with new columns specified by the call.
Unfortunately, the tidyr functions have little relationship to their stringr equivalents:

-   `extract()` is similar to `str_match()`
-   `separate()` with regex is similar to `str_split_fixed()`
-   `separate()` with numeric columns has no equivalent in stringr
-   `separate_rows()` is equivalent to `str_split()`

Additionally, tidyr uses base R regular expressions, not stringr.
There are relatively few differences between the regexp engines, but you need very different syntax to control options (e.g. ignoring case).
While it's important to keep tidyr dependencies lightweight (and installing stringr can be a challenge in some environments), it would be nice to use it if available, following the footsteps laid by [Radix Ordering in](https://github.com/tidyverse/tidyups/blob/main/003-dplyr-radix-ordering.md) [`dplyr::arrange()`](https://github.com/tidyverse/tidyups/blob/main/003-dplyr-radix-ordering.md).

Additionally there are a few gaps in the current API:

-   Neither stringr nor tidyr provide a particularly nice way to work with named capture groups.
    There's also scope for more directly matching column names to patterns if `extract()` didn't attempt to match the syntax of `separate()` so closely, e.g. `str_extract(x, c(type = ".*", "|", fruit = "orange|apple"))`.

-   tidyr only provides one function for splitting a string across rows, rather than columns: `separate_rows()`.
    What other functions should exist in this family?

-   `tidyr::separate()` can split up a string by position or by pattern.
    This now seems too clever, and makes it hard to notice that there are two different tools here.

### Components

To find a solution to this problem we need to first enumerate all the parts.
I think we can break the problem down into two somewhat independent components: how you break the string into pieces, and whether the number of pieces is fixed (and named) or varying (and named).
In total, I think this gives five ways to split up a string:

-   Into a fixed number of pieces by length/position, e.g. `"1m15"` -> `c(trt = "1", gender = "m", age = "15")`.
    This is closely related to `readr::read_fwf()`.

-   Into a varying number of pieces by length, e.g. `"abcdef"` -> `c("ab", "cd", "ef")`

-   Into a fixed number of pieces by a pattern, e.g. `"a/b/c"` -> `c(treatment = "a", group = "b", subgroup = "c").`

-   Into a varying number of pieces by a pattern, e.g. `"a/b/c"` -> `c("a", "b", "c").`

-   Into named groups, e.g. `"a(b)c"` -> `c(treatment = "a", group = "b", subgroup = "c")`

Matching these operations up with the existing stringr and tidyr function gives the following table:

| Split by | Length  | stringr         | tidyr             |
|----------|---------|-----------------|-------------------|
| Length   | Fixed   |                 | `separate()`      |
| Length   | Varying |                 |                   |
| Pattern  | Fixed   | `str_split_n()` | `separate()`      |
| Pattern  | Varying | `str_split()`   | `separate_rows()` |
| Group    | Fixed   | `str_match()`   | `extract()`       |

Note that `separate()` is repeated twice, and there are a number of empty cells.
Interestingly, there's no stringr function that allows you to extract multiple pieces by position; you currently have to call `str_sub()` multiple times yourself.

Generally, when the numbers of pieces might vary from entry to entry you'll want to create rows; when the numbers of pieces are fixed, you'll want to create columns.
This might not be true in every case, but I think it's true in enough cases that we can assume it as a constraint for this problem.
(Please let me know if you have a counter-example.)

We don't need to consider compound problems that need to be solved by splitting into rows and columns simultaneously because a compound problem (e.g. `"a-b-c/d-e-f/g-h-i"`) can always be solved by first splitting into rows and then into columns.

## Solutions

There are two possible approaches to solving this problem: providing paired tidyr and stringr functions, or attempting to eliminate the tidyr functions by using dplyr directly.
I think the first solution is more likely to be successful, but I've included a discussion of the second because I have twice thought it was the "obvious" way forward and needed a more thorough analysis to see the drawbacks.

### Paired tidyr and stringr functions

| Package | Length  | Input                    | Output                       |
|---------|---------|--------------------------|------------------------------|
| tidyr   | fixed   | data frame + column spec | data frame with more rows    |
| tidyr   | varying | data frame + column spec | data frame with more columns |
| stringr | fixed   | character vector         | data frame                   |
| stringr | varying | character vector         | list of character vectors    |

The vast majority of the work will occur in the stringr functions.
The tidyr functions would primarily be wrappers that take care of extracting the column and adding the new rows/columns to the input data frame.
tidyr would require a new helper similar to [`inflate()`](https://github.com/tidyverse/dplyr/pull/5888).
`tidyr::uncount()` and `tidyr::separate_rows()` would be rewritten to use this new function.

What do we call these functions?
Naming constraints:

-   The name of each stringr functions should the same name as the tidyr equivalent plus the standard `str_` prefix.

-   Use suffixes to distinguish between fixed and varying.
    If we assume a strong connection fixed-columns and varying-rows, obvious suffixes would be `wider` and `longer`.

### Eliminate tidyr functions

Can we eliminate the tidyr functions in favour of just stringr + dplyr?

Can't cleanly decouple this into stringr + dplyr functions, because there's no way to create multiple rows in dplyr; that appears to be fundamentally a tidyr operation.

<https://github.com/tidyverse/dplyr/issues/5874>; <https://github.com/tidyverse/dplyr/pull/5888>

### Conditional stringr dependency

Use stringr regexps if stringr is installed, or pattern wrapped with `stringr::regexp()` or friends.
If stringr not installed, message that using base R; provide `perl()` or similar to suppress that message if you deliberately want to use PCRE.

### 

## Implications for teaching
